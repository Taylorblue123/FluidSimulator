#include "SimulatorWorld.ch"
#include <cmath>
#include <iostream>
#include <stdexcept>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#define GLM_ENABLE_EXPERIMENTAL
#include <glm/gtx/matrix_cross_product.hpp> // Include for matrixCross3
#include <glm/gtx/orthonormalize.hpp>      // Include for orthonormalize
#include <GL/glew.h>
#include <GLFW/glfw3.h>
#include <vector>
#include <ctime>   // For time()
#include <algorithm> // For std::min and std::max
#include <iostream> // For std::cout and std::endl
#include <stdexcept> // For std::runtime_error
#include <cmath> // For std::sqrt and std::pow
#include <limits> // For std::numeric_limits
#include "Utils.h"
#include "CollisionDetection.h"
#include <limits>
#include <glm/gtx/orthonormalize.hpp>
#include <glm/gtx/matrix_cross_product.hpp>
#include "Integrators.h" // Include the new integrators header
#include <omp.h>
#include <algorithm> // For std::sort, std::fill
#include <glm/gtx/euler_angles.hpp>    // For glm::eulerAngleYXZ
#include <thrust/sort.h> // Already present in SimulatorWorld.ch
#include <thrust/copy.h> // Already present in SimulatorWorld.ch
#include <thrust/execution_policy.h> // Add this for thrust::device

// Define a maximum speed for color visualization. Speeds at or above this will be fully red.
const float MAX_VISUALIZED_SPEED = 5.0f;

SimulatorWorld::SimulatorWorld(
    const int complexity,
    const int numSpheres,
    const float radius,
    const float velocity,
    const float mass,
    const float worldSize,
    const float spheresSpacing,
    const float influenceRadius,
    const float targetDensity,
    const float pressureCoefficient,
    const float viscosityCoefficient
) : complexity(complexity), // Use direct initialization
    numSpheres(numSpheres),
    radius(radius),
    velocity(velocity),     // This is the initial velocity magnitude
    mass(mass),             // This is the default particle mass
    worldSize(worldSize), // This is now the local half-extent
    spheresSpacing(spheresSpacing),
    influenceRadius(influenceRadius),
    targetDensity(targetDensity),
    pressureCoefficient(pressureCoefficient),
    viscosityCoefficient(viscosityCoefficient),
    worldRotationEuler(0.0f, 0.0f, 0.0f), // Initial rotation
    worldTranslationVec(0.0f, 0.0f, 0.0f)  // Initial translation
{

    // Initialize random seed
    srand(static_cast<unsigned int>(time(0)));

    this->spheres = new SphereBV[this->numSpheres]; // Allocate memory for the spheres array
    this->CubeWorldPosition = nullptr; // Initialize CubeWorldPosition to nullptr

    // Initialize spatial lookup structures
    // The size of startIndices depends on the range of cell keys generated by getCellKeyFromHash.
    // If getCellKeyFromHash uses 'modulo N', then startIndices should be size N.
    // User's original getCellKeyFromHash used spatialLookup.size() (i.e., numSpheres) as modulo.
    if (this->numSpheres > 0) {
        this->spatialLookup.resize(this->numSpheres);
        this->startIndices.resize(this->numSpheres); 
    }

    updateWorldTransform(); // Initialize transform matrices

    // Initialize the simulation world
    initializeWorld(this->spheresSpacing); // Pass the member spheresSpacing
}

SimulatorWorld::~SimulatorWorld() {
    delete[] spheres;
    delete[] CubeWorldPosition;
    // No need to delete Entry objects in spatialLookup as it's now std::vector<Entry>
}

void SimulatorWorld::initializeWorld(float spheresSpacingParam) { // Changed signature to match usage
    // Initialize the world boundary
    initializeWorldBoundary();

    // Create a Utils instance for random number generation
    Utils utils;
    int spheresPerSide = static_cast<int>(std::cbrt(this->numSpheres)); // Calculate the number of spheres per side
    float spacing = 2.0f * this->radius + spheresSpacingParam; // Spacing between spheres based on their radius // Use parameter

    glm::vec3 initialVelocityVec(0.0f, this->velocity, 0.0f); // Using member 'velocity'

    for (int i = 0; i < this->numSpheres; i++) {
        // Initialize sphere as a volume (3D grid)  
        float x = (i % spheresPerSide - spheresPerSide / 2.0f + 0.5f) * spacing; // Calculate x position
        float y = ((i / spheresPerSide) % spheresPerSide - spheresPerSide / 2.0f + 0.5f) * spacing; // Calculate y position
        float z = (i / (spheresPerSide * spheresPerSide) - spheresPerSide / 2.0f + 0.5f) * spacing; // Calculate z position
        glm::vec3 center(x, y, z); // Create the center position of the sphere

        // Generate color based on radius, mass, and velocity
        glm::vec3 colorVal; // Renamed to avoid conflict with glm::color
        float currentSpeed = glm::length(initialVelocityVec);
        float t = 0.0f;
        if (MAX_VISUALIZED_SPEED > 1e-6f) { // Avoid division by zero or tiny numbers
            t = glm::clamp(currentSpeed / MAX_VISUALIZED_SPEED, 0.0f, 1.0f);
        } else if (currentSpeed > 1e-6f) {
            t = 1.0f; // If max speed is zero but current is not, make it full red
        }

        colorVal.r = t;
        colorVal.g = 1.0f - t;
        colorVal.b = 0.0f;

        // Use member variables for sphere creation
        this->spheres[i] = SphereBV(center, this->radius, initialVelocityVec, this->mass, this->complexity, colorVal, i);
    }

    // After initializing spheres, update spatial lookup for the first time
    if (this->numSpheres > 0) {
       updateSpatialLookup();
    }
}

void SimulatorWorld::shoot(glm::vec3 cameraFront) {
    // Randomly select a sphere to shoot
    int randomIndex = rand() % numSpheres;
    SphereBV& sphereToShoot = spheres[randomIndex];
    //Utils instance
    // Utils utils; // Removed unused variable

    // Generate shoot in the direction of the camera
    glm::vec3 cameraDirection = glm::normalize(cameraFront); // Use camera direction as the shoot direction
    //Fix the z axis to the ground plane
    cameraDirection.z = -worldSize;
    glm::vec3 randomVelocity = cameraDirection * velocity;

    // Set the new velocity for the selected sphere
    sphereToShoot.velocity = randomVelocity;

    sphereToShoot.P = randomVelocity * sphereToShoot.mass;
    
}

void SimulatorWorld::updateWorldTransform() {
    glm::mat4 rotationMat = glm::eulerAngleYXZ(glm::radians(worldRotationEuler.y), 
                                               glm::radians(worldRotationEuler.x), 
                                               glm::radians(worldRotationEuler.z));
    glm::mat4 translationMat = glm::translate(glm::mat4(1.0f), worldTranslationVec);
    
    worldTransformMatrix = translationMat * rotationMat;
    inverseWorldTransformMatrix = glm::inverse(worldTransformMatrix);
}


void SimulatorWorld::initializeWorldBoundary() {
    // Define CubeWorldPosition as local vertices of a cube centered at origin
    // with extents defined by this->worldSize (which is a half-extent)
    cubicWorldVertices.clear();
    delete[] CubeWorldPosition; // Ensure to delete if re-initializing
    CubeWorldPosition = new glm::vec3[8]; 
    float s = this->worldSize; // Use the member worldSize as half-extent
    CubeWorldPosition[0] = glm::vec3(-s, -s, -s); // Bottom-left-back
    CubeWorldPosition[1] = glm::vec3( s, -s, -s); // Bottom-right-back
    CubeWorldPosition[2] = glm::vec3( s,  s, -s); // Top-right-back
    CubeWorldPosition[3] = glm::vec3(-s,  s, -s); // Top-left-back
    CubeWorldPosition[4] = glm::vec3(-s, -s,  s); // Bottom-left-front
    CubeWorldPosition[5] = glm::vec3( s, -s,  s); // Bottom-right-front
    CubeWorldPosition[6] = glm::vec3( s,  s,  s); // Top-right-front
    CubeWorldPosition[7] = glm::vec3(-s,  s,  s); // Top-left-front
    
    //Unify the cube vertices to the same color
    glm::vec3 color(1.0f, 1.0f, 1.0f); // White color
    for (int i = 0; i < 8; i++) {
        vertice v;
        v.pos = CubeWorldPosition[i]; // Store local positions
        v.color = color;
        cubicWorldVertices.push_back(v); // Add vertex to the mesh
    }

    // Use explicit edge indices for a wireframe cube
    indices.clear();
    indices = {
        0,1, 1,2, 2,3, 3,0,   // back face
        4,5, 5,6, 6,7, 7,4,   // front face
        0,4, 1,5, 2,6, 3,7    // connecting edges
    };
}


void SimulatorWorld::updateSpatialLookup() {
    if (numSpheres == 0 || spatialLookup.empty() || startIndices.empty()) {
        return; // Nothing to update or structures not initialized
    }

    // 1. Populate host spatialLookup vector
    // This loop populates the std::vector<Entry> this->spatialLookup on the host.
    // The #pragma omp parallel for is for host-side parallelism.
    #pragma omp parallel for
    for (int i = 0; i < this->numSpheres; ++i) {
        // glm::ivec3 cellCoords = getCellCoords(this->spheres[i].predictedPosition, this->influenceRadius);
        glm::ivec3 cellCoords = getCellCoords(this->spheres[i].predictedPosition, this->influenceRadius);
        
        int cellHash = getCellHashFromCoords(cellCoords);
        int cellKey = getCellKeyFromHash(cellHash);
        this->spatialLookup[i] = Entry(i, cellKey); // Assuming Entry constructor is available
    }

    // 2. Sort on the device using Thrust
    // Create a device_vector from the host vector
    thrust::device_vector<Entry> d_lookup(this->spatialLookup.begin(), this->spatialLookup.end());
    
    // Perform sort on the device, explicitly specifying the device execution policy
    thrust::sort(thrust::device, d_lookup.begin(), d_lookup.end(), CompareEntriesFunctor());
    
    // Copy the sorted data back to the host vector
    thrust::copy(d_lookup.begin(), d_lookup.end(), this->spatialLookup.begin());

    // 3. Populate startIndices on the host using the sorted host vector
    std::fill(this->startIndices.begin(), this->startIndices.end(), this->numSpheres); 

    // This loop must be serial because it relies on the order from the sort
    // and checks the previous element (spatialLookup[i-1]).
    for (int i = 0; i < this->numSpheres; ++i) {
        int cellKey = this->spatialLookup[i].cellKey;
        // If this is the first particle overall or the first in a new cellKey block
        if (i == 0 || this->spatialLookup[i-1].cellKey != cellKey) {
            if (cellKey >= 0 && cellKey < this->startIndices.size()) { // Boundary check
                 this->startIndices[cellKey] = i;
            }
        }
    }
}


void SimulatorWorld::updateDensitiesAndPressureForces() {
    if (numSpheres == 0) return;

    // updateSpatialLookup() is called at the beginning of this function,
    // and it will now use predictedPosition thanks to the change above.
    // This ensures the grid is consistent with the positions used for SPH.

    // --- Part 1: Calculate Densities for all particles using predicted positions ---
    #pragma omp parallel for
    for (int i = 0; i < numSpheres; ++i) {
        SphereBV& particle_i = spheres[i];
        particle_i.density = 0.0f; // Reset density for recalculation

        // Use predictedPosition for neighborhood search
        glm::ivec3 centerCellCoords = getCellCoords(particle_i.predictedPosition, this->influenceRadius);

        // Iterate over the 3x3x3 neighborhood of cells
        for (int dz = -1; dz <= 1; ++dz) {
            for (int dy = -1; dy <= 1; ++dy) {
                for (int dx = -1; dx <= 1; ++dx) {
                    glm::ivec3 neighborCellCoords = centerCellCoords + glm::ivec3(dx, dy, dz);
                    int neighborCellHash = getCellHashFromCoords(neighborCellCoords);
                    int neighborCellKey = getCellKeyFromHash(neighborCellHash);

                    if (neighborCellKey < 0 || neighborCellKey >= startIndices.size()) continue;

                    int cellStartIndex = startIndices[neighborCellKey];
                    
                    // Iterate particles in this neighbor cell
                    for (int k = cellStartIndex; k < numSpheres; ++k) {
                        const Entry& entry = spatialLookup[k];
                        if (entry.cellKey != neighborCellKey) {
                            break; 
                        }

                        int particle_j_idx = entry.particleIndex;
                        // For density calculation, we only need particle_j's predictedPosition
                        const SphereBV& particle_j = spheres[particle_j_idx];


                        // Use predicted positions for distance calculation
                        glm::vec3 r_ij_vec = particle_i.predictedPosition - particle_j.predictedPosition;
                        float dist_sq = glm::dot(r_ij_vec, r_ij_vec);

                        if (dist_sq < this->influenceRadius * this->influenceRadius) {
                            particle_i.density += this->mass * SmoothingKernel(this->influenceRadius, std::sqrt(dist_sq));
                        }
                    }
                }
            }
        }
        // Ensure density is not zero to avoid division by zero later
        if (particle_i.density < 1e-6f) particle_i.density = 1e-6f;
    }

    // --- Part 2: Calculate Pressure Forces for all particles using predicted positions and calculated densities ---
    // This loop must run AFTER all densities have been computed.
    #pragma omp parallel for
    for (int i = 0; i < numSpheres; ++i) {
        SphereBV& particle_i = spheres[i];
        glm::vec3 pressureForce_i_val(0.0f); // Initialize pressure force for this particle

        float pressure_i_val = convertDensityToPressure(particle_i.density); // Uses density of particle_i

        // Neighborhood search for pressure forces based on PREDICTED position
        glm::ivec3 centerCellCoords = getCellCoords(particle_i.predictedPosition, this->influenceRadius);

        for (int dz = -1; dz <= 1; ++dz) {
            for (int dy = -1; dy <= 1; ++dy) {
                for (int dx = -1; dx <= 1; ++dx) {
                    glm::ivec3 neighborCellCoords = centerCellCoords + glm::ivec3(dx, dy, dz);
                    int neighborCellHash = getCellHashFromCoords(neighborCellCoords);
                    int neighborCellKey = getCellKeyFromHash(neighborCellHash);

                    if (neighborCellKey < 0 || neighborCellKey >= startIndices.size()) continue;

                    int cellStartIndex = startIndices[neighborCellKey];
                    for (int k = cellStartIndex; k < numSpheres; ++k) {
                        const Entry& entry = spatialLookup[k];
                        if (entry.cellKey != neighborCellKey) break;

                        int particle_j_idx = entry.particleIndex;
                        if (i == particle_j_idx) continue; // Don't calculate force with self

                        // Read particle_j's density (computed in Part 1)
                        const SphereBV& particle_j = spheres[particle_j_idx]; 

                        // Use predicted positions for distance and direction vector
                        glm::vec3 r_ij_vec = particle_i.predictedPosition - particle_j.predictedPosition;
                        float distance = glm::length(r_ij_vec);

                        if (distance < this->influenceRadius && distance > 1e-6f) { 
                            float pressure_j_val = convertDensityToPressure(particle_j.density); // Uses density of particle_j
                            
                            glm::vec3 grad_W_spiky_direction = glm::vec3(0.0f);
                            if (distance > 1e-9f) { 
                                grad_W_spiky_direction = r_ij_vec / distance;
                            }
                            float grad_W_spiky_magnitude = SmoothingKernelDerivative(this->influenceRadius, distance);
                            
                            // Ensure densities are not zero for the division
                            float density_i_sq = particle_i.density * particle_i.density;
                            float density_j_sq = particle_j.density * particle_j.density;
                            if (std::abs(density_i_sq) < 1e-9f) density_i_sq = 1e-9f;
                            if (std::abs(density_j_sq) < 1e-9f) density_j_sq = 1e-9f;

                            float term_i = pressure_i_val / density_i_sq;
                            float term_j = pressure_j_val / density_j_sq;
                            
                            pressureForce_i_val -= this->mass * (term_i + term_j) * grad_W_spiky_magnitude * grad_W_spiky_direction;
                        }
                    }
                }
            }
        }
        particle_i.force += pressureForce_i_val; 
    }
}



void SimulatorWorld::stepSimulation(float deltaTime, float damping, int integratorType, float gravityCoeff) {
    
    std::vector<std::pair<SphereBV*, SphereBV*>> collisionPairs; // Keep local
    // Pass the current worldTransformMatrix and the local worldSize to CollisionDetection
    CollisionDetection collisionDetection(spheres, numSpheres, worldSize, worldTransformMatrix, &collisionPairs);
    // Broad phase collision detection might also need to be aware of predicted vs actual positions
    // depending on when it's called relative to SPH and integration.
    // For now, assuming it works with current positions or is robust enough.
    collisionDetection.broadCollisionDetection(damping); 

    resetForces(); 
    applyGravityForces(gravityCoeff, deltaTime); // This updates predictedPosition for all spheres
                                                 // and adds gravity to sphere.force

    // Call updateSpatialLookup AFTER predicted positions are set by applyGravityForces
    // and BEFORE updateDensitiesAndPressureForces uses the grid.
    if (numSpheres > 0) {
        updateSpatialLookup(); // This will now use predictedPosition
    }

    updateDensitiesAndPressureForces(); // Calculates SPH forces using predictedPosition and the updated grid
    updateViscosity(); // Call placeholder or implemented method (ensure it also uses predictedPosition if appropriate)

    // Integrate state for all spheres using RK4
    #pragma omp parallel for
    for (int i = 0; i < numSpheres; i++) {
        SphereBV& currentSphere = spheres[i];

        currentSphere.applyDamping(damping); // Damping applied after SPH forces

        /* Part (A) Compute updated state variables using RK4 */
        // The integrator needs the current derived quantities (velocity, omega)
        // which are calculated based on the state variables (P, L, rotation)

        SphereBV nextState;
        switch (integratorType) {
            case 0: // Euler Integrator
                nextState = EulerIntegrator(currentSphere, deltaTime);
                break;
            case 1: // Midpoint Integrator
                nextState = MidpointIntegrator(currentSphere, deltaTime);
                break;
            case 2: // RK4 Integrator
                nextState = RK4Integrator(currentSphere, deltaTime);
                break;
            case 3: // Velocity Verlet Integrator
                nextState = VelocityVerletIntegrator(currentSphere, deltaTime);
                break;
            default: nextState = RK4Integrator(currentSphere, deltaTime); // Default to RK4
        }

        // Update the sphere's primary state variables from the integrator result
        currentSphere.center = nextState.center;
        currentSphere.P = nextState.P;
        currentSphere.velocity = currentSphere.P / currentSphere.mass;

        /* Part (C) Update related variables (transform, color) */
        currentSphere.transform = glm::translate(glm::mat4(1.0f), currentSphere.center) *
                                   glm::scale(glm::mat4(1.0f), glm::vec3(currentSphere.radius));

        // Update color based on new velocity etc.
        glm::vec3 updatedColor; // Use a different variable name to avoid confusion
        float speed = glm::length(currentSphere.velocity);
        float t = 0.0f;
        if (MAX_VISUALIZED_SPEED > 1e-6f) { // Avoid division by zero or tiny numbers
            t = glm::clamp(speed / MAX_VISUALIZED_SPEED, 0.0f, 1.0f);
        } else if (speed > 1e-6f) {
            t = 1.0f; // If max speed is zero but current is not, make it full red
        }
        // Seawater blue color scheme
        // updatedColor.r = 0.0f + t * 0.5f;
        // updatedColor.g = 0.4f + t * 0.3f;
        // updatedColor.b = 0.7f + t * 0.1f;

        //Red for high speed
        updatedColor.r = t;
        updatedColor.g = 0.0f;
        updatedColor.b = 1.0f - t;
        
        currentSphere.color = updatedColor;
    }

    collisionDetection.handleCollision(); // Handle collisions by reversing velocities
    
    #pragma omp parallel for
    for (int i = 0; i < numSpheres; ++i) {
        spheres[i].velocity = spheres[i].P / spheres[i].mass;
    }
}


void SimulatorWorld::stopSimulation() {
    // Stop the simulation and clean up resources
    delete[] spheres; // Free the memory allocated for spheres
    spheres = nullptr; // Set pointer to nullptr to avoid dangling pointer
    delete[] CubeWorldPosition; // Free the memory allocated for CubeWorldPosition
    CubeWorldPosition = nullptr; // Set pointer to nullptr to avoid dangling pointer
    cubicWorldVertices.clear(); // Clear the vertices of the cubic world
}

// Reset the simulation to its initial state
void SimulatorWorld::resetSimulation() {
    // Clean up existing spheres to prevent memory leaks
    if (this->spheres) { // Check if spheres array exists
        for (int i = 0; i < this->numSpheres; i++) {
            if (this->spheres[i].mesh) {
                delete this->spheres[i].mesh;
                this->spheres[i].mesh = nullptr;
            }
        }
    }
    //PRINT VARIABLES VALUES
    //Turn off the marble mode to reset the simulation
    std::cout << "Resetting simulation with the following parameters:" << std::endl;

    std::cout << "Current parameters:" << std::endl;
    std::cout << "Number of spheres: " << this->numSpheres << std::endl;
    std::cout << "World size: " << this->worldSize << std::endl;

    // Reset the simulation by reinitializing the world
    initializeWorld(this->spheresSpacing); // Reinitialize the world with new spheres

    // After re-initializing spheres, update spatial lookup
    if (this->numSpheres > 0) {
       updateSpatialLookup();
    }
}

//Render the simulation world in the current time step
void SimulatorWorld::render() {
    // Render the simulation world and spheres
    // Simple debug output
    for (int i = 0; i < numSpheres; i++) {
        std::cout << "Sphere " << i << ": Position = (" << spheres[i].center.x << ", " << spheres[i].center.y << ", " << spheres[i].center.z << ")" << std::endl;
    }
}





